import syssys.path.append('../solver')sys.path.append('../tracer')sys.path.append('../analysis')from tracer import Tracerfrom wrapper import wrfrom traceable_random import random, random_function#### TEST'''tr.str_addr = True''''''n=5def generator(problem_size=n):    return [random.choice([0,1]) for x in range(problem_size)](output1, trace1) = tr.get_trace(generator)print output1tr.display_trace(trace1)#print trace1def pt(g, t):    return tr.play_trace(g, t)(output2, trace2) = pt(generator, trace1)print output2tr.display_trace(trace2)#print trace2''''''#@random_functiondef generator():    if random.uniform(0,1) < 0.5:        return (a(), a(), b())    else:        return (b(), b(), a())@random_functiondef a():    return sum([random.uniform(0,1) for _ in range(2)])@random_functiondef b():    return random.randint(5, 10)    #return random.choice([a, b])()(output1, trace1) = tr.get_trace(generator)print output1#print "trace tree:"#tr.display_trace_tree(trace1)#print trace1print "trace:"tr.display_trace(trace1)#tr.display_trace_tree(trace1)dtree = DerivationTree(trace1)dtree.trace_to_tree()dtree.display_tree()''''''def pt(g, t):    return tr.play_trace(g, t)(output2, trace2) = pt(generator, trace1)print output2tr.display_trace(trace2)#print trace2''''''Sent -> Sub PredSub -> NPPred -> Verb PPNP -> Det NounNP -> Det Adjs NounPP -> Prep NPAdjs -> Adj AdjsAdjs -> AdjVerb -> 'sat' | 'stood'Det -> 'a' | 'the'Prep -> 'on' | 'under'Noun -> 'cat' | 'dog' | 'floor' | 'mat'Adj -> 'big' | 'small' | 'red' | 'black''''## GRAMMAR TO PROGRAM 1RC = random.choicedef English_randsol(): return Sent()@random_function # not neededdef Sent(): return Sub() + Pred()@random_function # not neededdef Sub(): return NP()@random_function # not neededdef Pred(): return Verb() + PP()@random_functiondef NP(): return RC([NP1, NP2])() #choose before expanding@random_functiondef NP1(): return Det() + Noun()@random_functiondef NP2(): return Det() + Adjs() + Noun()@random_function # not neededdef PP(): return Prep() + NP()@random_functiondef Adjs(): return RC([Adjs1, Adjs2])() #choose before expanding@random_functiondef Adjs1(): return Adj() + Adjs()@random_functiondef Adjs2(): return Adj()@random_functiondef Verb(): return RC(['sat ', 'stood '])@random_functiondef Det(): return RC(['a ', 'the '])@random_functiondef Prep(): return RC(['on ', 'under '])@random_functiondef Noun(): return RC(['cat ', 'dog ', 'floor ', 'mat '])@random_functiondef Adj(): return RC(['big ', 'small ', 'red ', 'black '])'''randsol()''''''## GRAMMAR TO PROGRAM 2 - closer to original grammar but 'lambda' not informative in 'display'RC = random.choicedef English_randsol(): return Sent()@random_function # not neededdef Sent(): return Sub() + Pred()@random_function # not neededdef Sub(): return NP()@random_function # not neededdef Pred(): return Verb() + PP()@random_functiondef NP(): return RC([lambda : Det() + Noun(), lambda : Det() + Adjs() + Noun()])() #choose before expanding#@random_function#def NP1(): return Det() + Noun()#@random_function#def NP2(): return Det() + Adjs() + Noun()@random_function # not neededdef PP(): return Prep() + NP()@random_functiondef Adjs(): return RC([lambda : Adj() + Adjs(), lambda : Adj()])() #choose before expanding@random_functiondef Adjs1(): return Adj() + Adjs()@random_functiondef Adjs2(): return Adj()@random_functiondef Verb(): return RC(['sat ', 'stood '])@random_functiondef Det(): return RC(['a ', 'the '])@random_functiondef Prep(): return RC(['on ', 'under '])@random_functiondef Noun(): return RC(['cat ', 'dog ', 'floor ', 'mat '])@random_functiondef Adj(): return RC(['big ', 'small ', 'red ', 'black '])'''@random_functiondef a():    return sum([random.uniform(0,1) for x in range(2)])@random_functiondef b():    return random.randint(5, 10)def aab_bba_randsol():    if random.uniform(0,1) < 0.5:        return (a(), a(), b())    else:        return (b(), b(), a())def mat():    return [[[random.choice([0,1]) for _x in range(2)] for _y in range(2)] for _z in range(2)]#################### Test GP randsol ####################n=3def boolean_GP_randsol(problem_size=n):    global vars    vars = ['x'+str(i) for i in range(problem_size)]    return randexpr(problem_size)@random_functiondef randexpr(depth):    'Create a random Boolean expression.'    if depth==1 or random.uniform(0,1)<1.0/(2**depth-1):        return random.choice(vars)    if random.uniform(0,1)<1.0/3:        return 'not' + ' ' + randexpr(depth-1)    else:        return '(' + randexpr(depth-1) + ' ' + random.choice(['and','or']) + ' ' + randexpr(depth-1) + ')'    def solgen():    return generator()@random_functiondef generator():    expr_type =  random.choice(['var','uop','biop'])    if expr_type == 'var':        return random.choice(['x1','x2','x3'])    if expr_type == 'uop':        return 'not' + ' ' + generator()    else:        return '(' + generator() + ' ' + random.choice(['and','or']) + ' ' + generator() + ')'    #####if __name__ == "__main__":    randsol = mat #aab_bba_randsol # a # generator  # solgen # boolean GP as used in the paper    tr = Tracer(rs=randsol, tt=True)     tr.acquire_wrapper(wr)        ###    (output1, trace1) = tr.get_trace()    print("output1:")    print(output1)    print("trace1:")    tr.display_trace(trace1)    ###    '''    # generate a trace and view it    random.seed(120)    (output1, trace1) = tr.get_trace()    assert output1 == "(x2 or x1)" # we have chosen seed to give this    print("output1:")    print(output1)    print("trace1:")    tr.display_trace(trace1)    # edit: if it has any occurences of 'or', change the first to 'and'.    # then view the new trace.    for k in trace1:        if trace1[k][1] == 'or':            trace1[k] = (trace1[k][0], 'and')            break    else:        print("no result: run again until 'or' appears.")        raise ValueError    print("trace1 after edit:")    tr.display_trace(trace1)    # use play_trace to "fix" the trace after the edit. which parts    # will be reusable?    output2, trace2 = tr.play_trace(trace1)    print("output2:")    print(output2)    print("trace2:")    tr.display_trace(trace2)    '''